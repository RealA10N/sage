
enum MatchingEnd {
    While,
    If,
    Else,
    Function,
}

enum Option<T> {
    Some(T),
    Nothing,
}

const MAX_MATCHING_LEVEL_COUNT = 512;
let static mut MATCHING_LEVEL: &mut Option<MatchingEnd> = Null;
let mut level = [Option<MatchingEnd> of Nothing] * MAX_MATCHING_LEVEL_COUNT;
MATCHING_LEVEL = &mut level as &mut Option<MatchingEnd>;

let static mut MATCH_DEPTH: Int = 0;

print("#include <stdint.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

typedef union cell {
    int64_t i;
    double f;
    union cell *p;
} cell;

cell tape[200000], *refs[1024], *ptr = tape, **ref = refs, reg, ffi_channel[256], *ffi_ptr = ffi_channel;

unsigned int ref_ptr = 0;
void (*funs[10000])(void);");

let static mut FUNCTION_COUNT: Int = 0;
let static mut FUNCTION_LEVEL: Int = 0;

def function() {
    println("void f", FUNCTION_COUNT, "() {");
    FUNCTION_COUNT += 1;
    FUNCTION_LEVEL += 1;
    MATCHING_LEVEL[MATCH_DEPTH] = Option<MatchingEnd> of Some(MatchingEnd of Function);
    MATCH_DEPTH += 1;
}

def while_loop() {
    println("while (reg.i) {");
    MATCHING_LEVEL[MATCH_DEPTH] = Option<MatchingEnd> of Some(MatchingEnd of While);
    MATCH_DEPTH += 1;
}

def if_statement() {
    println("if (reg.i) {");
    MATCHING_LEVEL[MATCH_DEPTH] = Option<MatchingEnd> of Some(MatchingEnd of If);
    MATCH_DEPTH += 1;
}

def else_statement() {
    println("} else {");
    MATCHING_LEVEL[MATCH_DEPTH] = Option<MatchingEnd> of Some(MatchingEnd of Else);
}

def end() {
    MATCH_DEPTH -= 1;
    match MATCHING_LEVEL[MATCH_DEPTH] {
        of Some(of While) => println("}"),
        of Some(of If) => println("}"),
        of Some(of Else) => println("}"),
        of Some(of Function) => {
            println("}");
            FUNCTION_LEVEL -= 1;
        },
        _ => println("Error: Unmatched end statement"),
    }
}

let static mut IS_MAIN_SETUP: Bool = False;

def setup_main() {
    if FUNCTION_LEVEL == 0 && !IS_MAIN_SETUP {
        println("int main() {");
        for let mut i=0; i<FUNCTION_COUNT; i += 1 {
            println("funs[", i, "] = f", i, ";");
        }
        println("reg.i = 0;");
        IS_MAIN_SETUP = True;
    }
}

def comment(s: &Char) {}

def set(n: Int) {
    setup_main();
    println("reg.i = ", n, ";");
}

def call() {
    setup_main();
    println("funs[reg.i]();");
}

def return_statement() {
    setup_main();
    println("return;");
}

def save() {
    setup_main();
    println("*ptr = reg;");
}

def restore() {
    setup_main();
    println("reg = *ptr;");
}

def move(n: Int) {
    setup_main();
    println("ptr += ", n, ";");
}

def where() {
    setup_main();
    println("reg.p = ptr;");
}

def deref() {
    setup_main();
    println("*ref++ = ptr; ptr = ptr->p;");
}

def refer() {
    setup_main();
    println("ptr = *--ref;");
}

def index() {
    setup_main();
    println("reg.p += ptr->i;");
}

def bitwise_nand() {
    setup_main();
    println("reg.i = ~(reg.i & ptr->i);");
}

def add() {
    setup_main();
    println("reg.i += ptr->i;");
}

def sub() {
    setup_main();
    println("reg.i -= ptr->i;");
}

def mul() {
    setup_main();
    println("reg.i *= ptr->i;");
}

def div() {
    setup_main();
    println("reg.i /= ptr->i;");
}

def rem() {
    setup_main();
    println("reg.i %= ptr->i;");
}

def gez() {
    setup_main();
    println("reg.i = reg.i >= 0;");
}

def put_stdout_char() {
    setup_main();
    println("putchar(reg.i);");
}

def put_stdout_int() {
    setup_main();
    println("printf(\"%lld\", reg.i);");
}

def put_stdout_float() {
    setup_main();
    println("printf(\"%f\", reg.f);");
}